# ocr_QA.py = oil_classifier_Question_Answer
from bootstrap import *
from USEFUL_UTILS.ssDecoder_car_bart import ss_2_CarParams
from bootstrap import root_path

CarParam = ss_2_CarParams()

from PROJECTS.LLM_OIL_CLASSIFIER.osr_filter_attributes import filter_car_params
from PROJECTS.LLM_OIL_CLASSIFIER.ocr_QA_universal import generate_Answer
from PROJECTS.LLM_OIL_CLASSIFIER.ocr_select_oil_assortment import select_Oil_assortment

import json
import re
from datetime import datetime
from llama_cpp import Llama

model_dir = root_path + '/DATA_CATALOGS/llm_models/gguf/'

# MODEL_PATH = model_dir + '//Qwen2.5-Coder-3B-Instruct.Q5_K_M.gguf' #гораздо хуже Mistral
# MODEL_PATH = model_dir + '/DeepSeek-R1-Distill-Qwen-7B.Q4_K_M.gguf' #гораздо хуже Mistral
## Полный отстой: Meta-Llama-3.1-8B-Instruct-Q5_K_M.gguf, Phi-3-mini-4k-instruct (Microsoft)

MODEL_PATH = model_dir + '/Mistral-7B-Instruct-v0.3-Q4_K_M.gguf'  # наилучший вариант по качеству и скорости

MAX_len_param_df = 25  # в ячейке A_text в среднем 400 символов - кол-во строк больше, значит срез не качественный - общий поиск
LIM_len_param_df = 13

llm = Llama(
    model_path=MODEL_PATH,
    n_ctx=8192,  # 8192
    n_batch=1024,
    n_gpu_layers=99,
    n_threads=10,
    verbose=False,
)

system_prompt_3 = (
    "Ты — авторитетный технический эксперт-химик и консультант по всем автомобильным жидкостям и маслам. "
    "Твой ответ должен быть безупречно **точным, объективным и максимально полезным** для клиента, строго основанным на предоставленном КОНТЕКСТЕ."

    "\n### КРИТИЧЕСКИЕ ПРАВИЛА (RAG Fidelity):"
    "\n1. **Запрет на галлюцинации:** Любой факт, характеристика или рекомендация **обязаны быть извлечены** из блока '### КОНТЕКСТ'."
    "\n2. **Обработка отсутствия данных:** Если в блоке '### КОНТЕКСТ' нет информации для точного ответа по какому-либо продукту, ответь: 'К сожалению, в предоставленной технической информации отсутствуют данные для точного ответа на ваш вопрос.'"
    "\n3. **Чистота вывода:** Строго запрещено выводить или упоминать в ответе любые служебные теги (<<<, >>>, ===)."

    "\n### СТРУКТУРА ОТВЕТА (Строгий Markdown):"
    "\n1. **Заголовок:** Начни с лаконичного заголовка, подтверждающего запрос и параметры автомобиля."
    "\n2. **Содержание:** Отвечай на вопрос, используя **строгий Markdown** (жирный шрифт, буллеты, нумерованные списки). Разделяй каждый тип продукта (масло, жидкость) в отдельный, легко читаемый пункт нумерованного списка."
    "\n3. **Вёрстка:** Формулируй законченные, профессиональные мысли. Используй двойной перенос строки (`\n\n`) для разделения логических абзацев."
    "\n4. **Завершение:** В конце дай краткую рекомендацию по периодичности замены, если она присутствует в КОНТЕКСТЕ."
)

system_prompt_2 = (
    "Ты — авторитетный технический эксперт-химик и консультант по всем автомобильным жидкостям и маслам. "
    "Твой ответ должен быть безупречно **точным, объективным и максимально полезным** для клиента, строго основанным на предоставленном КОНТЕКСТЕ."

    "\n### КРИТИЧЕСКИЕ ПРАВИЛА (RAG Fidelity):"
    "\n1. **СТРОГОЕ ИЗВЛЕЧЕНИЕ:** Любой факт, характеристика или рекомендация **обязаны быть извлечены** только из блока '### КОНТЕКСТ'."
    "\n2. **ЧИСТЫЙ ВЫВОД:** Строго запрещено выводить в ответе любые служебные теги (<<<, >>>, ===, ### КРИТИЧЕСКИЕ ПРАВИЛА, ### СТРУКТУРА ОТВЕТА)."
    "\n3. **ОТСУТСТВИЕ ДАННЫХ:** Если в '### КОНТЕКСТ' нет информации для точного ответа, ответь: 'К сожалению, в предоставленной технической информации отсутствуют данные для точного ответа на ваш вопрос.' И ничего больше."

    "\n### ФОРМАТ ОТВЕТА (Строгий Markdown):"
    "\n1. **НАЧАЛО:** Ответ должен начинаться с **лаконичного заголовка (Markdown, например, # или ##)**, подтверждающего запрос и параметры автомобиля, **без использования служебных слов типа 'Заголовок' или 'Ответ на вопрос'**."
    "\n2. **СОДЕРЖАНИЕ:** Разделяй каждый тип продукта (масло, жидкость) в отдельный, легко читаемый пункт нумерованного списка."
    "\n3. **ВЁРСТКА:** Используй **строгий Markdown** (жирный шрифт, буллеты, нумерованные списки) и двойной перенос строки (`\n\n`) для разделения логических абзацев. **Заверши ответ краткой рекомендацией по периодичности замены, если она присутствует в КОНТЕКСТЕ.**"
)

system_prompt_1 = (
    "Ты — профессиональный технический консультант по автомобильным жидкостям и маслам. "
    "Отвечай ТОЛЬКО полезной информацией из КОНТЕКСТА. НИКАКИХ заголовков, подзаголовков, слов «Заголовок», «Вёрстка», «Завершение», «Ответ на вопрос», лишних #, **, пустых строк и размышлений.\n\n"

    "КРИТИЧЕСКИЕ ПРАВИЛА:\n"
    "1. Отвечай СРАЗУ с фактов, без вступлений.\n"
    "2. Используй только Markdown: **жирный** для названий жидкостей, обычный текст для объёмов и спецификаций, • для пунктов.\n"
    "3. Если данных нет — пиши: «Информации по этому узлу в базе нет».\n"
    "4. НИКОГДА не пиши слова: «Заголовок», «Вёрстка», «Завершение», «Ответ на вопрос», «Вот», «Рекомендация».\n"
    "5. Запрещено начинать ответ с # или ##.\n\n"

    "ПРИМЕР ПРАВИЛЬНОГО ОТВЕТА:\n"
    "Моторное масло:\n"
    "• Объём: 5.7 л\n"
    "• Спецификация: VW 508.00\n"
    "• Периодичность замены: каждые 15 000 км\n\n"
    "Тормозная жидкость:\n"
    "• Объём: 0.9 л\n"
    "• Спецификация: DOT-4\n"
    "• Периодичность замены: каждые 2 года\n\n"
    "Масло в АКПП\n"
    "• Объём: 8.5 л\n"
    "• Спецификация: ATF DW-1"
)


system_prompt_4 = (
    "Ты — технический консультант по автомобильным жидкостям и маслам. "
    "Отвечай ТОЛЬКО полезной информацией из КОНТЕКСТА, без рассуждений и пояснений.\n\n"

    "ПРАВИЛА:\n"
    "1. Сразу пиши факты, без вступлений.\n"
    "2. Используй жирный шрифт для названий жидкостей, обычный текст для объёмов и спецификаций, • для пунктов.\n"
    "3. Если данных по узлу нет — пиши: «Информации по этому узлу в базе нет».\n"
    "4. Не используй слова: «Заголовок», «Вёрстка», «Завершение», «Ответ на вопрос», «Вот», «Рекомендация».\n"
    "5. Не начинай ответ с # или ##.\n"
    "6. Пиши максимально кратко, только по тем узлам, которые которые относятся к проблеме клиента.\n\n"

    "\n### ФОРМАТ ОТВЕТА:"
    "\n1. В заголовке ответа обязательно должны присутствовать параметры автомобиля (как у производителя), и краткая формулировка запроса клиента экспертным языком, **без использования служебных слов типа 'Заголовок' или 'Ответ на вопрос'**."
    "\n2. Разделяй каждый тип продукта (масло моторное, Масло трансмиссионное) в отдельный, легко читаемый пункт нумерованного списка."
    "\n3. Для разделения логических абзацев используй двойной перенос строки. **Заверши ответ краткой рекомендацией по периодичности замены, если она присутствует в КОНТЕКСТЕ.**"
    "\n4. **ПРИМЕР:**"
    "\nRange Rover Vogue 2009, 3.6 TDI - Жидкость тормозная и масло задней раздатки"
    "Жидкость тормозная:"
    "- DOT 3 или DOT 4."
    "- Объём заливки: 0.8 л."
    "- Периодичность замены: 45 тыс. км или 3 года."
    ""
    "Масло задней раздатки:"
    "- масло Mobil 1 75W-90."
    "- Объём заливки: 4.5 л."
    "- Периодичность замены: 15 тыс. км или 12 месяцев."
)

system_prompt_5 = (
    "Ты — профессиональный технический консультант по автомобильным жидкостям и маслам. "
    "Отвечай ТОЛЬКО полезной информацией из КОНТЕКСТА. НИКАКИХ заголовков, подзаголовков, слов «Заголовок», «Вёрстка», «Завершение», «Ответ на вопрос», лишних #, **, пустых строк и размышлений.\n\n"

    "КРИТИЧЕСКИЕ ПРАВИЛА:\n"
    "1. Отвечай СРАЗУ с фактов, без вступлений.\n"
    "2. Используй только жирный текст для названий жидкостей, обычный текст для объёмов и спецификаций, • для пунктов.\n"
    "3. Если данных нет — пиши: «Информации по этому узлу в базе нет».\n"
    "4. НИКОГДА не пиши слова: «Заголовок», «Вёрстка», «Завершение», «Ответ на вопрос», «Вот», «Рекомендация».\n"
    "5. Запрещено начинать ответ с # или ##.\n\n"

    "ПРИМЕР ПРАВИЛЬНОГО ОТВЕТА:\n"
    "** для Opel Astra H (L35, L48, L69) 1.4 **\n" # "\n"  ** для OPEL ASTRA H 1.4 **
    "Моторное масло:\n"
    "• Объём: 5.7 л\n"
    "• Спецификация: VW 508.00\n"
    "• Периодичность замены: каждые 15 000 км\n\n"
    "Тормозная жидкость:\n"
    "• Объём: 0.9 л\n"
    "• Спецификация: DOT-4\n"
    "• Периодичность замены: каждые 2 года\n\n"
    "Масло в АКПП\n"
    "• Объём: 8.5 л\n"
    "• Спецификация: ATF DW-1"
)




def promtConstructor(query: str) -> str:
    print(f"model = {MODEL_PATH.split('/')[-1]}")
    if 'Mistral' in MODEL_PATH:
        print("promtConstructor = Mistral")
        return f"[INST] {system_prompt}\n\n{query}  [/INST]"

    print("promtConstructor = Universal DeepSeek")
    return (
        f"<|im_start|>system\n{system_prompt}<|im_end|>\n"
        f"<|im_start|>user\n{query}<|im_end|>\n"
        f"<|im_start|>assistant\n"
    )


#     return f"{system_prompt}\n\n{query}"


def get_max_tokens(param_df_len: int) -> int:
    if param_df_len == 1: return 350
    MAX_TOKENS = 1200
    calculated_tokens = int(170 * param_df_len) + 150
    return calculated_tokens if calculated_tokens < MAX_TOKENS else MAX_TOKENS


def query_2_Context(client_query: str, param_df, applied_filters, CarParam) -> str:
    param_df = param_df[:LIM_len_param_df]
    all_A_text = f'\n=== ТИП ЖИДКОСТИ === '.join(param_df['A_text'].unique()) + ' .'
    print(f"len param_df = {len(param_df)}, len all A_text = {len(all_A_text)}")
    query = "### КОНТЕКСТ\n<<<ВОПРОС КЛИЕНТА>>> " + client_query
    tail = query[-1]
    if tail != "?":
        query += "?"
    query += " <<</ВОПРОС КЛИЕНТА>>>"

    if applied_filters:

        lst_param = []
        for param in applied_filters:
            lst_param.append(f"{param}: {getattr(CarParam, param)}")

        query += "\n<<<ПАРАМЕТРЫ ВОПРОСА>>> " + ", ".join(lst_param) + " <<</ПАРАМЕТРЫ ВОПРОСА>>>"
        query += "\n\n<<<ТЕХНИЧЕСКАЯ ИНФОРМАЦИЯ>>>\n=== ТИП ЖИДКОСТИ === " + all_A_text + " <<</ТЕХНИЧЕСКАЯ ИНФОРМАЦИЯ>>>"

    query += "\n\nn**Задача:** Предоставьте лаконичный, структурированный ответ на запрос клиента:\n" + client_query

    return query


def answerGenerate(query: str, system_prompt) -> str:
    def generate_answer(query: str, param_df) -> dict:
        prompt = promtConstructor(query)

        output = llm(
            prompt,
            max_tokens=get_max_tokens(len(param_df)),
            temperature=0.2,  ###
            stop=["<|im_end|>", "```"],  # ["<|im_end|>", "```", "\n\n", "\n{"],
            echo=False,
        )

        answer = output["choices"][0]["text"]

        return answer

    CarParam.ssDecoder(query)
    param_dct = {param: getattr(CarParam, param) for param in CarParam.RESULT_ATTRIBUTES}
    param_df, applied_filters = filter_car_params(param_dct)

    t1 = U24.tNow()
    flag_LLM_FREE_SEARCH = True
    oil_and_fluids = ''
    if 0 < len(param_df) <= MAX_len_param_df:
        print(f"\n*** query_with_context -- > OIL_CLASSIFIER_PARAMS\n\n")
        query_with_context = query_2_Context(query, param_df, applied_filters, CarParam)
        oil_and_fluids = select_Oil_assortment(param_df)
        answer = generate_answer(query_with_context, param_df)
        if answer:
            flag_LLM_FREE_SEARCH = False

    if flag_LLM_FREE_SEARCH:
        print(f"\n*** generate_Answer -- > LLM FREE SEARCH\n\n")
        query = system_prompt + "\n### КОНТЕКСТ\n" + query
        result = generate_Answer(query, llm, k=4)
        answer = result["answer"]

    if oil_and_fluids:
        answer += "\n\n" + oil_and_fluids

    print(f"delta time LLM = {(U24.tNow() - t1).total_seconds()}\n\n")

    return answer


BOILERPLATE_PREFIXES = [
    'доброго всем здравия',
    'начну с самого начала',
    'подскажите пожалуста',
    'подскажите', 'пожалуйста',
    'нужен совет',
    'спасибо за ответ',
    'вопрос по',
    'несколько вопросов',
    'здравствуйте',
    'скажите',
    'помогите',
    'таки говоря',
    'возник вопрос',
    'и снова',
    'добрый день',
    'доброго времени суток',
    'добрый вечер',
    'доброго дня', 'день добрый', 'доброго времени', 'спасибо'
]

_boiler_re_parts = [rf'(?:^|(?<=[\.\!\?]\s))\s*{re.escape(p)}\s*[,:-]?\s*' for p in BOILERPLATE_PREFIXES]
BOILER_RE = re.compile('|'.join(_boiler_re_parts), re.IGNORECASE | re.UNICODE)


def _strip_boilerplate(s: str) -> str:
    if not isinstance(s, str): return ''
    prev, cur = None, s
    while prev != cur:
        prev = cur
        cur = BOILER_RE.sub('', cur).strip()
    return re.sub(r'\s+', ' ', cur, flags=re.UNICODE).strip()


if __name__ == "__main__":
    tests = ['заправочные объёмы всех технических жидкостей для джили монджаро 2 литра бензин 2023?',
             'range rover vogue 2009 год, 3.6 TDI жидкость тормозная, и масло задней раздатки',
             "масло для ниссан санни 1999 бензин 1.6",
             "какое масло в АКПП бмв х5 2015 дизель", 'ваз 2123.2011г.,какое масло залито в гур',
             "сколько литров масла в киа рио 2018",
             'масло моторное для opel astra h',
             'VOLVO  XC 90 3.2 Насос муфты Haldex ,фильтр на насос муфты Haldex,масло в насос муфты Haldex',
             'MAZDA  CX-9 3.7  AWD Масло в раздатку (самые оптимальные - короткие сроки поставки?)',
             'VW  POLO седан 1.6 Жидкость  ATF  Для АКПП  G055025A2  красная  7  литров',
             'BMW  X5 (E53) 3.0 i масло в мост передний, задний, раздатку, коробку ',

             ]

    """

    , 
             ]



         'mazda original oil ultra 5w30 5л',

             "Замёрз замок в автомобиле, что делать?",

             'добрый день! пришло время менять масло в акпп. какое выбрать ? (до этого был залит оригинал с завода',
             'антикор скрытых полостей',



        "как удалить наклейку с кузова",
        "подбери антигель на зиму",
    """

    promt_list = [system_prompt_5]

    T1 = U24.tNow()
    t_promt_1 = 0
    t_promt_2 = 0
    t_promt_3 = 0

    for i, query in enumerate(tests):
        query = _strip_boilerplate(query)
        print(f"\n\n{'=' * 60}{i}/{len(tests)}\nзапрос: {query}")
        for j, system_prompt in enumerate(promt_list, 1):
            N_promt = f"promt_{j}"

            tt1 = U24.tNow()
            answer = answerGenerate(query, system_prompt)
            time_delta = (U24.tNow() - tt1).total_seconds()

            print(f"{N_promt} t_delta = {time_delta:.0f}\nзапрос: {query}\nответ: {answer}\n{'-' * 60}")

            if N_promt == 'promt_1':
                t_promt_1 += time_delta

            if N_promt == 'promt_2':
                t_promt_2 += time_delta

            if N_promt == 'promt_3':
                t_promt_3 += time_delta



    print(f"\n promt_1 среднее время на 1 запрос: {t_promt_1 // (i + 1)}")
    # print(f"\n promt_2 среднее время на 1 запрос: {t_promt_2 // (i + 1)}")
    # print(f"\n promt_3 среднее время на 1 запрос: {t_promt_3 // (i + 1)}")

    """ 


    поменять сортировку выдачи - мало моторное вверх

       Рейтинг LUKOIL/GAZPROM  
        масло для Опель - Мерседес MERCEDES-BENZ"""






